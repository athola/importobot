Metadata-Version: 2.4
Name: importobot
Version: 0.1.0
Summary: A tool to convert Zephyr test cases from JSON format to Robot Framework format
Requires-Python: >=3.10
Description-Content-Type: text/markdown
License-File: LICENSE
Requires-Dist: robotframework>=6.0.0
Requires-Dist: robotframework-seleniumlibrary>=6.0.0
Requires-Dist: robotframework-sshlibrary>=3.8.0
Requires-Dist: robotframework-requests>=0.9.4
Requires-Dist: robotframework-databaselibrary>=1.2.4
Requires-Dist: pytest-cov>=7.0.0
Requires-Dist: psutil>=7.0.0
Requires-Dist: matplotlib>=3.10.6
Requires-Dist: numpy>=2.2.6
Dynamic: license-file

# Importobot - Test Framework Converter

[![Test](https://github.com/athola/importobot/actions/workflows/test.yml/badge.svg)](https://github.com/athola/importobot/actions/workflows/test.yml)
[![Lint](https://github.com/athola/importobot/actions/workflows/lint.yml/badge.svg)](https://github.com/athola/importobot/actions/workflows/lint.yml)
[![Python 3.10+](https://img.shields.io/badge/python-3.10+-blue.svg)](https://www.python.org/downloads/)
[![uv](https://img.shields.io/endpoint?url=https://raw.githubusercontent.com/astral-sh/uv/main/assets/badge/v0.json)](https://github.com/astral-sh/uv)

**Importobot** converts test cases from test management tools (Zephyr, JIRA/Xray, TestLink) into Robot Framework format. It automates the migration process that would otherwise require manual conversion.

## Why Importobot?

Organizations often have thousands of test cases in legacy test management tools. When teams want to adopt Robot Framework for automated testing, they face a choice:
- **Manual Migration**: Weeks or months of copy-paste work, prone to errors and inconsistencies.
- **Starting Over**: Losing years of accumulated test knowledge and business logic.
- **Status Quo**: Staying with suboptimal tooling due to migration complexity.

Importobot automates the conversion process:
- Convert test suites with a single command.
- **Bulk convert** entire directories of test cases.
- Maintain test structure and metadata during conversion.
- Generate Robot Framework files that run without modification.
- Built using TDD practices for reliability.

## Current Capabilities

### Supported Input Formats
- ✅ **Atlassian Zephyr** (JSON export)
- 🚧 **JIRA/Xray** (Roadmap Q4 2025)
- 🚧 **TestLink** (Roadmap Q1 2026)

### What Gets Converted
- Test case structure and hierarchy
- Test steps and expected results
- Metadata (tags, priorities, descriptions)
- Multi-line comments
- Verification points transformed into Robot Framework assertions
- SeleniumLibrary keywords for web testing

## How It Works

```
Input (Zephyr JSON)           →    Importobot Process    →    Output (Robot Framework)
┌─────────────────────┐            ┌─────────────────┐           ┌──────────────────────────┐
│ {                   │            │ 1. Parse JSON   │           │ *** Test Cases ***       │
│   "testCase": {     │     →      │ 2. Map Fields   │    →      │ Login Test               │
│     "name": "Login" │            │ 3. Generate     │           │   Go To    ${LOGIN_URL}  │
│     "steps": [...]  │            │    Keywords     │           │   Input Text  id=user   │
│   }                 │            │ 4. Validate     │           │   Click Button  Login    │
│ }                   │            └─────────────────┘           └──────────────────────────┘
└─────────────────────┘

## Development Setup

To set up the development environment:

1. Install dependencies:
   ```bash
   make sync
   ```

   This command will:
   - Set up the base environment with `uv sync`
   - Install the scripts package in development mode
   - Install required development dependencies (PyQt5, seaborn)

2. Run tests:
   ```bash
   make test
   ```
```

## Example

**Before (Zephyr Test Case):**
```json
{
  "testCase": {
    "name": "User Login Functionality",
    "description": "Verify user can login with valid credentials",
    "steps": [
      {
        "stepDescription": "Navigate to login page",
        "expectedResult": "Login page displays"
      },
      {
        "stepDescription": "Enter username 'testuser'",
        "expectedResult": "Username field populated"
      }
    ]
  }
}
```

**After (Generated Robot Framework):**
```robot
*** Test Cases ***
User Login Functionality
    [Documentation]    Verify user can login with valid credentials
    [Tags]    login    authentication

    # Navigate to login page
    Go To    ${LOGIN_URL}
    Page Should Contain    Login

    # Enter username 'testuser'
    Input Text    id=username    testuser
    Textfield Value Should Be    id=username    testuser
```

## API Reference

Importobot provides both a simple command-line interface and a comprehensive Python API for enterprise integration.

### Simple Usage (CLI)

```bash
# Convert a single file
importobot input.json output.robot

# Bulk convert directory
importobot --directory tests/ --output converted/

# Convert with suggestions for ambiguous cases
importobot input.json output.robot --suggestions
```

### Python API (Enterprise Integration)

#### Basic Conversion

```python
import importobot

# Core business functionality
converter = importobot.JsonToRobotConverter()

# Convert JSON string to Robot Framework
robot_code = converter.convert_json_string(json_data)

# Bulk convert files
results = converter.convert_directory("/path/to/zephyr/exports")
```

#### Advanced Enterprise Features

```python
from importobot.api import validation, converters, suggestions

# CI/CD Pipeline Integration
validation.validate_json_dict(test_data)  # Validate before conversion
validation.validate_safe_path(output_path)  # Security validation

# Advanced conversion engine access
engine = converters.GenericConversionEngine()
custom_config = {"keywords": "selenium", "format": "robot"}
result = engine.convert(test_data, config=custom_config)

# QA Team: Handle ambiguous test cases
suggestion_engine = suggestions.GenericSuggestionEngine()
fixes = suggestion_engine.suggest_improvements(problematic_test_data)
```

#### Configuration & Error Handling

```python
import importobot

# Enterprise configuration
max_size = importobot.config.MAX_JSON_SIZE_MB
test_url = importobot.config.TEST_SERVER_URL

# Comprehensive error handling
try:
    converter = importobot.JsonToRobotConverter()
    result = converter.convert_file("test.json")
except importobot.exceptions.ValidationError as e:
    print(f"Input validation failed: {e}")
except importobot.exceptions.ConversionError as e:
    print(f"Conversion failed: {e}")
except importobot.exceptions.ParseError as e:
    print(f"JSON parsing failed: {e}")
```

### API Design Philosophy

Importobot follows **pandas-inspired API patterns** for enterprise readiness:

- **Clean Public Interface**: `import importobot` provides core functionality
- **Enterprise Toolkit**: `importobot.api.*` for advanced features
- **Version Stability**: Public API contracts remain stable across versions
- **Type Safety**: Full type hints and `TYPE_CHECKING` support
- **Professional Standards**: Follows industry best practices from pandas, numpy, flask

**Business Use Cases:**
1. **Bulk Conversion Pipeline**: Convert thousands of test cases with single commands
2. **CI/CD Integration**: Validate and convert in automated pipelines
3. **QA Suggestion Engine**: Handle incorrect/ambiguous test cases intelligently

## Installation

### Prerequisites

- Python 3.10 or higher
- [uv](https://github.com/astral-sh/uv) package manager

### Installing uv

This project uses [uv](https://github.com/astral-sh/uv) for package management. Install uv first:

**macOS/Linux:**
```bash
curl -LsSf https://astral.sh/uv/install.sh | sh
```

**Windows (PowerShell):**
```bash
powershell -c "irm https://astral.sh/uv/install.ps1 | iex"
```

Verify the installation:
```bash
uv --version
```

### Project Setup

Once uv is installed, set up the project:

```bash
# Clone the repository
git clone https://github.com/athola/importobot.git
cd importobot

# Install project dependencies
uv sync --dev

# Verify the installation by running tests
uv run pytest
```

## Quick Start

### Basic Usage
```bash
# Convert a single Zephyr JSON file
uv run importobot zephyr_export.json converted_tests.robot

# Batch convert multiple files
uv run importobot --batch input_folder/ output_folder/
```

### Interactive Business Benefits Demo
```bash
# Run the interactive demo showcasing business benefits with visualizations
make interactive-demo

# Or run directly
uv run python scripts/interactive_demo.py

# For non-interactive testing
make interactive-demo-test
```

### Migration Workflow

1. **Export**: Export test cases from your source system.
2. **Convert**: Use a single command to convert the test suite to Robot Framework.
3. **Validate**: The generated tests are immediately executable for verification.
4. **Integrate**: The tests can be integrated directly into your existing CI/CD pipelines.

### Interactive Business Benefits Demo

This interactive demo showcases the business benefits of Importobot with data visualizations.

**Prerequisites**

Make sure you have the required dependencies installed:

```bash
uv pip install seaborn matplotlib pandas numpy
```

**Running the Demo**

To run the interactive demo:

```bash
uv run python scripts/interactive_demo.py
```

The demo will guide you through:

1. Business case and time savings visualization
2. Basic test conversion example
3. User registration flow conversion
4. SSH file transfer operations
5. Database and API integration
6. Performance at scale visualization
7. Intelligent test improvement suggestions
8. Comprehensive business benefits summary

Each section includes visualizations that demonstrate the dramatic improvements over manual processes, with prompts to continue between sections.

**What the Demo Shows**

- **Time Savings**: Visual comparison of manual vs automated conversion times
- **Cost Benefits**: Financial impact visualization
- **Performance Metrics**: Speed, accuracy, and scalability comparisons
- **Real Examples**: Actual test cases converted from Zephyr JSON to Robot Framework
- **Business Impact**: ROI calculations and efficiency gains

The demo uses seaborn and matplotlib to create professional-quality visualizations that clearly communicate the business value of Importobot.

**Visualizations**

When running in non-interactive mode, plots are saved to the `visualizations/` directory as PNG files:

- `importobot_business_case_[timestamp].png` - Time and cost comparison
- `importobot_performance_[timestamp].png` - Performance at scale metrics
- `importobot_business_benefits_[timestamp].png` - Comprehensive business benefits

To clean up generated visualizations:
```bash
make clean
```

### Configuration

Importobot can be configured with environment variables:

- `IMPORTOBOT_TEST_SERVER_URL`: Overrides the default test server URL.
- `IMPORTOBOT_TEST_SERVER_PORT`: Overrides the default test server port.

## Recent Improvements

### Artifact Management
- Enhanced `.gitignore` to properly exclude generated artifacts and test output files
- Added comprehensive `clean` and `deep-clean` Makefile targets to remove temporary files
- Removed accidentally committed artifacts and ensured repository cleanliness

### Code Quality
- Fixed linting issues throughout the codebase using `ruff` and other tools
- Removed unused imports and variables to reduce code clutter
- Standardized code formatting with automated tools
- Improved error handling and validation patterns

### Test Reliability
- Fixed failing tests related to missing test data files
- Improved test data management and file organization
- Enhanced test suite reliability and consistency

### Latest Developments (September 2025)

#### Interactive Demo System & Business Intelligence
- **Added `scripts/` directory** with comprehensive interactive demo infrastructure for showcasing business benefits and conversion capabilities
- **Created modular demo architecture** with separate components for configuration, logging, validation, scenarios, and visualization
- **Implemented executive dashboards** with KPI cards, performance curves, competitive positioning, and ROI analysis
- **Built portfolio analysis capabilities** across different business scenarios and scales
- **Performance testing framework** for enterprise-scale validation with real-time visualization

#### Code Quality & Architecture Achievements
- **Achieved 9.96/10 lint score** through systematic code quality improvements and eliminated duplicate code patterns
- **Implemented shared utilities**: Created reusable components for pattern extraction (`utils/pattern_extraction.py`) and step comment generation (`utils/step_comments.py`)
- **Enhanced SSH infrastructure**: Comprehensive test coverage for all 42 SSH keywords with generative testing capabilities
- **Improved security handling**: Robust parameter extraction for sensitive SSH authentication and file operations
- **Modular keyword architecture**: Enhanced separation of concerns with shared base functionality

#### Test Coverage Expansion
- **Added extensive unit test suite** covering business domains, distributions, error handling, field definitions, JSON conversion, keywords, logging, progress reporting, security, suggestions, and validation
- **SSH keyword testing**: Complete coverage of connection, authentication, file operations, directory management, and interactive shell keywords
- **Security validation tests**: Parameter extraction, validation, and security compliance testing
- **Generated comprehensive test coverage** with additional test files for reliability and comprehensive validation

## CI/CD

Importobot is designed to be run in a CI/CD pipeline. It includes support for running in a headless environment by using a headless Chrome browser.

## Development

This project uses `uv` for dependency management and follows Test-Driven Development (TDD) and Extreme Programming (XP) principles.

### Setup

```bash
# Install all dependencies
uv sync --dev

# Install the project in editable mode
uv pip install -e .
```

### Running Tests

```bash
# Run all tests
uv run pytest

# Run specific test categories
uv run pytest tests/unit/
uv run pytest tests/integration/
```

### Code Quality

```bash
# Run all linting tools
make lint

# Auto-fix common issues
uv run ruff check --fix .
uv run ruff format .

# Clean generated artifacts
make clean
make deep-clean  # For more thorough cleanup
```
